# TCP 协议

## TCP 首部字段

- 源端口、目标端口(识别发送主机和接收主机上的程序)
- 序号(用于表示该数据包中数据是发送端整个数据中第几个字节的序列号)
- 校验和(用以判断数据是否被破坏)

## 三次握手

**TCP 提供面向有连接的传输管理，面向有连接指的是在通信开始之前先做好通信两端之间的准备工作。**

所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。

- 第一次握手（SYC=1, seq=x）：

  客户端发送一个数据包，指明连接服务器的端口号。

  发送完毕后，客户端进入`SYN_SEND`状态

- 第二次握手(SYN=1,ACK=1,seq=y,ACKnum=x+1)

  服务器发回确认包（ACK）应答。

  服务器端进入 `SYN_RCVD`状态

- 第三次握手(SYN=0, ACK=1, ACKnum=y+1)

  客户端再次发送确认包(ACK).

  客户端进入`ESTABLISHED`状态，当服务器接收到这个包时，也进入`ESTABLISHED`状态，TCP 握手结束。



客户端状态变化：LISTEN -> SYN_SENC -> ESTABLISHED

服务端状态变化：LISTEN -> SYN_RCVD -> ESTABLISHED.



##四次挥手

TCP 断开连接的时候，需要发送4个数据包，客户端或者服务器都可以主动发起断开操作，在 socket 编程中，任何一方执行close操作都可以产生挥手操作。

假设客户端关闭连接：

- 第一次挥手(FIN=1, seq=x)

  客户端发送一个FIN标志位置为1的包，标识自己没有数据可以发送，但是仍可以接收数据。

  发送完毕后，客户端进入`FIN_WAIT_1`状态。

- 第二次挥手(ACK=1,ACKnum=x+1)

  服务器接收到FIN包之后，发送一个数据包表明自己已经接收了请求，但还没做好关闭的准备。

  服务端发送完毕之后进入`CLOSE_WAIT`状态，客户端接收到到确认包之后，进入到`FIN_WAIT_2`状态，等待服务器关闭连接。

- 第三次挥手(FIN=1, seq=y)

  服务器端准备好关闭连接时，向客户端发送结束连接的请求，FIN位置置为1

  发送完毕后，服务器今日`LAST_ACK`状态，等待来自客户端的最后一个ACK.

- 第四次挥手(ACK=1,ACKnum=y+1)

  客户端接收到来自服务器的关闭请求，发送一个确认包，并进入`TIME_WAIT`状态，等待可能出现的要求重传ACK包。

  服务端接收到确认包之后，关闭连接，进入`CLOSE`状态。

  服务端等待某个固定的时间(两个最大的生命周期)之后，没有收到服务器端的ACK，认为服务器已经关闭了正常连接，于是客户端关闭连接，进入`CLOSE`状态。

客户端状态：ESTABLISHED -> FIN_WAIT_1 -> FIN_WAIT_2 -> TIME_WAIT -> CLOSED

服务端状态：ESTABLISHED -> CLOSE_WAIT -> LAST_ACK -> CLOSED



## TCP 传输介绍

**确认应答：**

1. 在TCP中，当发送端的数据到达主机的时候，接收端主机会返回一个已经收到的消息通知，这个消息叫做确认应答。
2. 在一定时间内没有确认应答，可以认为数据已经丢失，发送端会进行数据重发。
3. 接收端在接收到重复数据的时候，需要放弃重复的数据，那么如何确认数据是否重复呢，这里引入了序列编号的概念。
4. 序列编号是按顺序给发送数据的每一个字节都标上编号，接收端和发送端都可以根据编号进行重发和接收。就这样通过编号可以实现可靠传输。
5. 重发超时的时间是根据一段时间内通信的往返时间来确定的，数据在重发指定次数后，会停止重发，强制关闭。

**窗口控制和并发控制**

1. TCP 以段为单位发送数据，段的大小在三次握手的时候计算出来。
2. 每次发送后都需要一个应答的情况，会导致发送的往返时间太长，网络吞吐量会变差，因此引入了窗口的概念。
3. 在窗口内的数据无需等到应答，可以直接发送给服务端。
4. 在接到服务端的应答之后，可以根据段编号来移动窗口
5. 窗口控制的模式下，对需要重发的数据进行了改变，在接收到3个一样的确认应答的时候，进行数据重发。
6. 客户端在接收到重发的数据之后，可以判断当前接收到的数据段到哪了，然后继续发送对应的应答



**控制流**

1. TCP 提供了一种机制可以让发送端根据接收端的实际接收能力控制发送数据量，这就是所谓的控制流机制。
2. 接收端主机想发送端主机通知自己可以接收的数据大小，于是发送端会发送不超过这个大小的数据，改大小限度就被称为窗口大小。
3. 窗口大小是可以在发送过程中自行调整的。



**拥塞控制**

1. 在网络拥堵的时候，如果突然出现了一个很大的数据量，那么网络可能陷入瘫痪。为解决这个问题，通信在一开始的时候会通过一个慢启动的算法得出数值，对发送数据量进行控制
2. 为了在发送端调节数据量大小，定义了一个`拥塞窗口`的感念，在启动时将值设置为1，每次应答将窗口值+1.
3. 在后续发送的过程中，比较拥塞窗口和接收端接收主机通知的窗口大小，去其中较小的那个值，发送比这个值略小的数据量。











## TCP如何实现传输的可靠性

校验和

序列号

确认应答

重发控制

连接管理

窗口控制等







